
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Android Developer Fundamentals 08.3: JobScheduler</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="8-3"
                  title="Android Developer Fundamentals 08.3: JobScheduler"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="Welcome" duration="0">
        <p>この実践的なコードラボは<a href="https://developer.android.com/courses/fundamentals-training/toc-v2#unit_3_working_in_the_background" target="_blank">ユニット 3:</a> Android Developer Fundamentals (Version 2) コースの<a href="https://developer.android.com/courses/fundamentals-training/toc-v2#unit_3_working_in_the_background" target="_blank">バックグラウンドでの作業の一部</a>です。コードラボを順番に進めていくことで、このコースを最大限に活用することができます。</p>
<ul>
<li>コース内のコードラボの完全なリストは、<a href="https://developer.android.com/courses/fundamentals-training/toc-v2" target="_blank">Codelabs for Android Developer Fundamentals (V2)を</a>参照してください。</li>
<li>すべてのコンセプトチャプター、アプリ、スライドへのリンクなど、講座の詳細については、<a href="https://developer.android.com/courses/fundamentals-training/overview-v2" target="_blank">Android Developer Fundamentals（第2版）を</a>ご覧ください。</li>
</ul>
<p>注：このコースでは、「codelab」と「practical」という用語を使い分けています。</p>
<p>序章</p>
<p><code>AlarmManager</code> クラスを使用して、リアルタイムクロックや起動からの経過時間に基づいてイベントをトリガーすることができることを見てきました。しかし、ほとんどのタスクは正確な時間を必要とせず、システムとユーザーの要件の組み合わせに基づいてスケジュールする必要があります。例えば、ユーザーのデータとシステムリソースを保存するために、ニュースアプリは、デバイスが充電されてWi-Fiに接続されるまでニュースを更新するのを待つことができます。</p>
<p><a href="https://developer.android.com/reference/android/app/job/JobScheduler.html" target="_blank"><code>JobScheduler</code></a> クラスでは、タスクをいつ実行するかの条件やパラメータを設定することができます。これらの条件が与えられると、<code>JobScheduler</code> はジョブの実行をスケジュールするための最適な時間を計算します。例えば、ジョブのパラメータには、再起動時のジョブの持続性、デバイスが接続されているかどうか、デバイスがアイドル状態であるかどうかなどを設定することができます。</p>
<p>実行されるタスクは、<a href="https://developer.android.com/reference/android/app/job/JobService.html" target="_blank"><code>JobService</code>の</a>サブクラスとして実装され、指定されたパラメータに従って実行されます。</p>
<p><code>JobScheduler</code>はAPI 21以上を実行しているデバイスでのみ利用可能で、現在サポートライブラリでは利用できません。下位互換性がある場合は、<a href="https://developer.android.com/topic/libraries/architecture/workmanager" target="_blank"><code>WorkManager</code> を使用</a>してください。<code>WorkManager</code> API を使用すると、アプリプロセスの有無に関わらず、完了を保証する必要のあるバックグラウンドタスクをスケジュールすることができます。Google Play サービスを使用していないデバイスを含む、API 14 以上を実行しているデバイスでは、<code>WorkManager</code> は <code>JobScheduler</code> と同様の機能を提供します。</p>
<p>この実習では、通知をスケジュールするアプリを作成します。ユーザーが設定したパラメータが満たされ、システム要件を満たすと通知が投稿されます。</p>
<p>すでに知っておくべきこと</p>
<p>できるようになるはずです。</p>
<ul>
<li>通知を配信するアプリを作成します。</li>
<li>スピナービューから整数値を取得します。</li>
<li>ユーザー入力には<code>Switch</code>ビューを使用します。</li>
<li><code>PendingIntentsを作成します。</code></li>
</ul>
<p>あなたが学ぶこと</p>
<ul>
<li><code>JobServiceの実装方法。</code></li>
<li>特定の制約を持つ<code>JobInfo</code>オブジェクトを構築する方法。</li>
<li><code>JobInfo</code>オブジェクトに基づいて<code>JobService</code>をスケジュールする方法。</li>
</ul>
<p>あなたがすること</p>
<ul>
<li>ジョブが実行されていることをユーザに知らせるシンプルな通知を配信する <code>JobService</code> を実装します。</li>
<li><code>JobService</code>上の制約(デバイスが充電されるまで待機するなど)を設定するためのユーザ入力を取得します。</li>
<li><code>JobScheduler</code>を使用してジョブをスケジュールします。</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="App overview" duration="0">
        <p>この実習では、Notification Schedulerというアプリを作成します。このアプリでは、ユーザが制約を選択してジョブをスケジュールすることで、<code>JobScheduler</code>フレームワークをデモします。そのジョブが実行されると、アプリは通知を投稿します。(このアプリでは、通知は実質的に「ジョブ」です。)</p>
<p class="image-container"><img alt="Preview for the Notification Scheduler" style="width: 306.76px" src="img/cd843e845163afa3.png"> </p>
<p><code>JobSchedulerを使用するには、</code><a href="https://developer.android.com/reference/android/app/job/JobService.html" target="_blank"><code>JobService</code></a><code>と</code><a href="https://developer.android.com/reference/android/app/job/JobInfo.html" target="_blank"><code>JobInfoを</code></a><code>使用する必要があります。</code></p>
<ul>
<li><code>JobInfo</code> オブジェクトには、ジョブを実行するトリガーとなる条件のセットが含まれています。</li>
<li>ジョブサービスとは、<code>JobInfo</code>オブジェクトに設定された条件で実行されるジョブの実装です。</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="タスク1: JobServiceの実装" duration="0">
        <p>まずは、条件で決められた時間に実行するサービスを作成します。システムが自動的に<code>JobService</code>を実行してくれます。実装する必要があるのは、<code>onStartJob()</code>コールバックと<code>onStopJob()</code>コールバックのみです。</p>
<p><code>onStartJob()コールバックについて。</code></p>
<ul>
<li>システムがタスクを実行すべきと判断したときに呼び出されます。このメソッドでは、実行すべきジョブを実装します。</li>
<li>ジョブを別のスレッドで継続する必要があるかどうかを示すブール値を返します。<code>true</code>の場合、作業は別のスレッドにオフロードされ、アプリはジョブが完了したことを示すために、そのスレッドで明示的に<code>jobFinished()</code>を呼び出す必要があります。<code>false</code> の場合、システムは <code>onStartJob()</code> の終了時までにジョブが完了したことを知っており、システムはあなたに代わって <code>jobFinished()</code> を呼び出します。</li>
</ul>
<p>注意:<a href="https://developer.android.com/reference/android/app/job/JobService.html#onStartJob(android.app.job.JobParameters)" target="_blank"><strong><code>onStartJob()</code></strong></a>メソッドはメインスレッド上で実行されるため、長時間実行されるタスクは別のスレッドにオフロードされなければなりません。このアプリでは、単に通知を投稿しているだけなので、メインスレッド上で安全に行うことができます。</p>
<p><code>onStopJob()コールバックについて。</code></p>
<ul>
<li><code>JobInfo</code> に記述されている条件が満たされなくなった場合は、ジョブを停止しなければならず、システムは <code>onStopJob()</code> を呼び出します。</li>
<li><code>onStopJob()</code> コールバックは、ジョブが終了しなかった場合に何をするかを決定するブール値を返します。戻り値が真の場合、ジョブは再スケジュールされ、そうでない場合、ジョブは中止されます。</li>
</ul>
<p>1.1 プロジェクトと NotificationJobService クラスの作成</p>
<p>使用している最小SDKがAPI 21であることを確認してください。API 21以前では、必要なAPIの一部が不足しているため、<code>JobScheduler</code>は動作しません。</p>
<ol type="1" start="1">
<li>Notification Scheduler」というJavaプロジェクトを新規作成します。ターゲットSDKとしてAPI 21を使用し、Empty Activityテンプレートを使用します。</li>
<li><code>com.android.example.notificationschedulerパッケージの中に、JobServiceを継承する新しい</code>Java<code>クラスを作成します。新しいクラス NotificationJobService を呼び出します。</code></li>
<li>必要なメソッド、<code>onStartJob()</code>と<code>onStopJob()</code>を追加します。クラス宣言の横にある赤い電球をクリックして、「メソッドを実装」を選択し、「OK」を選択します。</li>
<li><code>AndroidManfest.xmlファイルの<application>タグ内で、以下の権限でJobServiceを登録してください。</code></li>
</ol>
<pre><code>&lt;service
   android:name=&#34;.NotificationJobService&#34;
   android:permission=&#34;android.permission.BIND_JOB_SERVICE&#34;/&gt;</code></pre>
<p>1.2 onStartJob()の実装</p>
<p><code>NotificationJobService.javaで以下の手順を実装します。</code></p>
<ol type="1" start="1">
<li>ジョブ」通知の通知 アイコンとして使用する画像アセットを追加します。画像に <code>ic_job_running</code> という名前を付けます。</li>
<li>通知マネージャのメンバ変数と通知チャネルIDの定数を宣言します。</li>
</ol>
<pre><code>NotificationManager mNotifyManager;

// Notification channel ID.
private static final String PRIMARY_CHANNEL_ID =
       &#34;primary_notification_channel&#34;;
</code></pre>
<ol type="1" start="1">
<li><code>onStartJob()</code>メソッドの中で、通知チャネルを作成するメソッドを定義します。</li>
</ol>
<pre><code>/**
* Creates a Notification channel, for OREO and higher.
*/
public void createNotificationChannel() {

   // Define notification manager object.
   mNotifyManager =
           (NotificationManager) getSystemService(NOTIFICATION_SERVICE);

   // Notification channels are only available in OREO and higher.
   // So, add a check on SDK version.
   if (android.os.Build.VERSION.SDK_INT &gt;=
           android.os.Build.VERSION_CODES.O) {

       // Create the NotificationChannel with all the parameters.
       NotificationChannel notificationChannel = new NotificationChannel
               (PRIMARY_CHANNEL_ID,
                       &#34;Job Service notification&#34;,
                       NotificationManager.IMPORTANCE_HIGH);

       notificationChannel.enableLights(true);
       notificationChannel.setLightColor(Color.RED);
       notificationChannel.enableVibration(true);
       notificationChannel.setDescription
               (&#34;Notifications from Job Service&#34;);

       mNotifyManager.createNotificationChannel(notificationChannel);
   }
} </code></pre>
<ol type="1" start="1">
<li><code>onStartJob()</code>内で、通知チャネルを作成するメソッドを呼び出します。アプリの<code>MainActivity</code>を起動する<code>PendingIntent</code>を作成します。このインテントは、通知のコンテンツ インテントです。</li>
</ol>
<pre><code>//Create the notification channel
createNotificationChannel();

//Set up the notification content intent to launch the app when clicked
PendingIntent contentPendingIntent = PendingIntent.getActivity
       (this, 0, new Intent(this, MainActivity.class), PendingIntent.FLAG_UPDATE_CURRENT);</code></pre>
<ol type="1" start="1">
<li><code>onStartJob()</code>では、以下の属性を持つ通知を構築して配信します。</li>
</ol>
<table>
<tr><td colspan="1" rowspan="1"><p>属性</p>
</td><td colspan="1" rowspan="1"><p>タイトル</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>コンテンツタイトル</p>
</td><td colspan="1" rowspan="1"><p><code>"</code>ジョブサービス</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>コンテンツテキスト</p>
</td><td colspan="1" rowspan="1"><p><code>"</code>あなたの仕事は走っている！<code>"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>コンテンツインテント</p>
</td><td colspan="1" rowspan="1"><p>コンテンツペンディングインテント</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>スモールアイコン</p>
</td><td colspan="1" rowspan="1"><p><code>R.drawable.ic_job_running</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>優先順位</p>
</td><td colspan="1" rowspan="1"><p><code>NotificationCompat.PRIORITY_HIGH</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>デフォルト</p>
</td><td colspan="1" rowspan="1"><p><code>NotificationCompat.DEFAULT_ALL</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>オートキャンセル</p>
</td><td colspan="1" rowspan="1"><p>真</p>
</td></tr>
</table>
<ol type="1" start="1">
<li>弦を抜いて</li>
<li>このアプリでは、すべての作業は<code>onStartJob()</code>コールバックで完了するため、onStartJob()が<code>false</code>を返すことを確認してください。</li>
</ol>
<p>ここに <code>onStartJob()</code> メソッドの完全なコードがあります。</p>
<pre><code>@Override
public boolean onStartJob(JobParameters jobParameters) {

   //Create the notification channel
   createNotificationChannel();

   //Set up the notification content intent to launch the app when clicked
   PendingIntent contentPendingIntent = PendingIntent.getActivity
           (this, 0, new Intent(this, MainActivity.class),
                   PendingIntent.FLAG_UPDATE_CURRENT);

   NotificationCompat.Builder builder = new NotificationCompat.Builder
           (this, PRIMARY_CHANNEL_ID)
           .setContentTitle(&#34;Job Service&#34;)
           .setContentText(&#34;Your Job ran to completion!&#34;)
           .setContentIntent(contentPendingIntent)
           .setSmallIcon(R.drawable.ic_job_running)
           .setPriority(NotificationCompat.PRIORITY_HIGH)
           .setDefaults(NotificationCompat.DEFAULT_ALL)
           .setAutoCancel(true);

   mNotifyManager.notify(0, builder.build());
   return false;
}</code></pre>
<ol type="1" start="1">
<li><code>onStopJob()</code>が<code>true</code>を返すことを確認してください。ジョブが失敗した場合、ジョブを削除するのではなく、再スケジューリングしたいからです。</li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="タスク2：ジョブ条件の実装（JobInfo" duration="0">
        <p><code>JobService</code> ができたので、ジョブを実行するための基準を確認しましょう。これには、<code>JobInfo</code> コンポーネントを使用します。様々なネットワーク接続タイプとデバイスステータスを使用して、ジョブを実行するための一連のパラメータ化された条件を作成します。</p>
<p>開始するには、このジョブが必要とするネットワークタイプを決定するために、ラジオボタンのグループを作成します。</p>
<p>2.1 ネットワーク制約の実装</p>
<p>ジョブを実行するための条件として考えられるのは、デバイスのネットワーク接続の状態です。特定のネットワーク条件が満たされた場合にのみ実行されるように<code>JobService</code>を制限することができます。オプションは3つあります。</p>
<ul>
<li><a href="https://developer.android.com/reference/android/app/job/JobInfo.html#NETWORK_TYPE_NONE" target="_blank"><code>NETWORK_TYPE_NONE</code>は、</a>ネットワーク接続の有無に関わらずジョブを実行することを意味します。これがデフォルト値です。</li>
<li><a href="https://developer.android.com/reference/android/app/job/JobInfo.html#NETWORK_TYPE_ANY" target="_blank"><code>NETWORK_TYPE_ANY</code>は</a>、ネットワーク（携帯電話、Wi-Fi）が利用可能な限り、ジョブが実行されることを意味します。</li>
<li><a href="https://developer.android.com/reference/android/app/job/JobInfo.html#NETWORK_TYPE_UNMETERED" target="_blank"><code>NETWORK_TYPE_UNMETERED</code></a>は、HotSpotを使用しないWi-Fiにデバイスが接続されている限り、ジョブが実行されることを意味します。</li>
</ul>
<p>アプリのレイアウトを作成する</p>
<p>アプリのレイアウトには、ユーザーがネットワークの基準を選択するラジオボタンが含まれています。</p>
<p class="image-container"><img alt="1ba0b4a44b4d4d28.png" style="width: 271.47px" src="img/1ba0b4a44b4d4d28.png"></p>
<p><code>activity_main.xml</code>ファイルに以下の手順を実装します。必ずすべてのディメンションと文字列リソースを抽出してください。</p>
<ol type="1" start="1">
<li>ルートビュー要素を垂直の<code>LinearLayout</code>に変更し、レイアウトのパディングを<code>16dp</code>にします。いくつかのエラーが出るかもしれませんが、これは後で修正します。</li>
</ol>
<pre><code>&lt;LinearLayout 

xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34;
   android:layout_width=&#34;match_parent&#34;
   android:layout_height=&#34;match_parent&#34;
   android:orientation=&#34;vertical&#34;
   android:padding=&#34;16dp&#34;&gt;

....

&lt;/LinearLayout&gt;</code></pre>
<ol type="1" start="1">
<li>テキストビューを以下の属性を持つように変更します。</li>
</ol>
<table>
<tr><td colspan="1" rowspan="1"><p>属性</p>
</td><td colspan="1" rowspan="1"><p>値</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>レイアウトの幅</p>
</td><td colspan="1" rowspan="1"><p><code>"</code>ラップコンテンツ<code>"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>レイアウトの高さ</p>
</td><td colspan="1" rowspan="1"><p><code>"</code>ラップコンテンツ<code>"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>テキスト</p>
</td><td colspan="1" rowspan="1"><p><code>"</code>ネットワークの種類が必要です。<code>"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>android:textAppearance</code></p>
</td><td colspan="1" rowspan="1"><p><code>"@style/TextAppearance.AppCompat.Subhead"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>レイアウトマージン</p>
</td><td colspan="1" rowspan="1"><p><code>"4dp"</code></p>
</td></tr>
</table>
<ol type="1" start="1">
<li><code>TextView</code>の下に、以下の属性を持つ<code>RadioGroup</code>コンテナ要素を追加します。</li>
</ol>
<table>
<tr><td colspan="1" rowspan="1"><p>属性</p>
</td><td colspan="1" rowspan="1"><p>値</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>レイアウトの幅</p>
</td><td colspan="1" rowspan="1"><p><code>"</code>ラップコンテンツ<code>"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>レイアウトの高さ</p>
</td><td colspan="1" rowspan="1"><p><code>"</code>ラップコンテンツ<code>"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>オリエンテーション</p>
</td><td colspan="1" rowspan="1"><p><code>"</code>すいへいよう</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:id</code></p>
</td><td colspan="1" rowspan="1"><p><code>"@+id/networkOptions"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>レイアウトマージン</p>
</td><td colspan="1" rowspan="1"><p><code>"4dp"</code></p>
</td></tr>
</table>
<p>注: <strong><code>RadioGroup</code></strong> 要素を使用すると、次のステップで定義する要素の子要素のうち 1 つだけをユーザーが選択できるようになります。詳細については、「<a href="https://developer.android.com/guide/topics/ui/controls/radiobutton.html" target="_blank">ラジオボタン」を</a>参照してください。</p>
<ol type="1" start="1">
<li>3つの<code>RadioButton</code>ビューを<code>RadioGroup</code>内の子要素として追加します。それぞれのラジオボタンについて、レイアウトの高さと幅を「<code>wrap_content</code>」に設定し、以下の属性を設定します。</li>
</ol>
<table>
<tr><td colspan="2" rowspan="1"><p>ラジオボタン1</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>テキスト</p>
</td><td colspan="1" rowspan="1"><p><code>"</code>なし<code>"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:id</code></p>
</td><td colspan="1" rowspan="1"><p><code>"@+id/noNetwork"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>チェック済み</p>
</td><td colspan="1" rowspan="1"><p><code>"真</code></p>
</td></tr>
<tr><td colspan="2" rowspan="1"><p>ラジオボタン 2</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>テキスト</p>
</td><td colspan="1" rowspan="1"><p><code>"</code>何でも</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:id</code></p>
</td><td colspan="1" rowspan="1"><p><code>"@+id/anyNetwork"</code></p>
</td></tr>
<tr><td colspan="2" rowspan="1"><p>ラジオボタン 3</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>テキスト</p>
</td><td colspan="1" rowspan="1"><p><code>"Wifi"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:id</code></p>
</td><td colspan="1" rowspan="1"><p><code>"@+id/wifiNetwork"</code></p>
</td></tr>
</table>
<ol type="1" start="1">
<li><code>RadioGroup</code>の下に2つの<code>Button</code>ビューを追加します。それぞれのボタンについて、高さと幅を「コンテンツをラップ」に設定し、以下の属性を設定します。</li>
</ol>
<table>
<tr><td colspan="2" rowspan="1"><p>ボタン1</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>テキスト</p>
</td><td colspan="1" rowspan="1"><p><code>"</code>予定表の仕事</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>オンクリック</p>
</td><td colspan="1" rowspan="1"><p><code>"</code>スケジュールジョブ</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>android:layout_gravity</code></p>
</td><td colspan="1" rowspan="1"><p><code>"center_horizontal"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>レイアウトマージン</p>
</td><td colspan="1" rowspan="1"><p><code>"4dp"</code></p>
</td></tr>
<tr><td colspan="2" rowspan="1"><p>ボタン2</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>テキスト</p>
</td><td colspan="1" rowspan="1"><p><code>"</code>仕事をキャンセル<code>"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>オンクリック</p>
</td><td colspan="1" rowspan="1"><p><code>"cancelJobs"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>android:layout_gravity</code></p>
</td><td colspan="1" rowspan="1"><p><code>"center_horizontal"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>レイアウトマージン</p>
</td><td colspan="1" rowspan="1"><p><code>"4dp"</code></p>
</td></tr>
</table>
<ol type="1" start="1">
<li><code>MainActivity</code> で、2 つのボタンのそれぞれに <code>onClick()</code> メソッドのスタブを追加します。</li>
</ol>
<p>選択したネットワークオプションを取得する</p>
<p><code>MainActivity.java</code>に以下の手順を実装します。必要に応じて文字列リソースを抽出します。</p>
<ol type="1" start="1">
<li><code>scheduleJob() メソッドで、</code>ID <code>で RadioGroup を見つけて、それを networkOptions という名前のインスタンス変数に保存します。</code></li>
</ol>
<pre><code>RadioGroup networkOptions = findViewById(R.id.networkOptions);
</code></pre>
<ol type="1" start="1">
<li><code>scheduleJob()</code> メソッドで、選択されたネットワーク ID を取得し、整数変数に保存します。</li>
</ol>
<pre><code>int selectedNetworkID = networkOptions.getCheckedRadioButtonId();
</code></pre>
<ol type="1" start="1">
<li><code>scheduleJob()</code>メソッドで、選択されたネットワーク・オプションのための整数変数を作成します。この変数をデフォルトのネットワーク・オプション（<code>NETWORK_TYPE_NONE</code>）に設定します。</li>
</ol>
<pre><code>int selectedNetworkOption = JobInfo.NETWORK_TYPE_NONE;</code></pre>
<p><code>int selectedNetworkOption = JobInfo.NETWORK_TYPE_NONE.</code></p>
<ol type="1" start="1">
<li><code>scheduleJob()</code> メソッドで、選択されたネットワーク ID を持つ switch 文を作成します。可能な ID のそれぞれにケースを追加します。</li>
<li><code>scheduleJob()</code> メソッドでは、ケースに応じて、選択したネットワーク・オプションに適切な <code>JobInfo</code> ネットワーク定数を割り当てます。</li>
</ol>
<pre><code>switch(selectedNetworkID){
   case R.id.noNetwork:
       selectedNetworkOption = JobInfo.NETWORK_TYPE_NONE;
       break;
   case R.id.anyNetwork:
       selectedNetworkOption = JobInfo.NETWORK_TYPE_ANY;
       break;
   case R.id.wifiNetwork:
       selectedNetworkOption = JobInfo.NETWORK_TYPE_UNMETERED;
       break;
}</code></pre>
<p>JobSchedulerとJobInfoオブジェクトの作成</p>
<ol type="1" start="1">
<li><code>JobSchedulerのメンバ変数を作成します。</code></li>
</ol>
<pre><code>private JobScheduler mScheduler;</code></pre>
<ol type="1" start="1">
<li><code>scheduleJob()メソッド内では、getSystemService()を使用してmSchedulerを初期化します。</code></li>
</ol>
<pre><code>mScheduler = (JobScheduler) getSystemService(JOB_SCHEDULER_SERVICE);</code></pre>
<ol type="1" start="1">
<li><code>JOB_ID</code>のメンバ定数を作成し、<code>0</code>に設定します。</li>
</ol>
<pre><code>private static final int JOB_ID = 0;</code></pre>
<ol type="1" start="1">
<li><code>scheduleJob()メソッドの中で、Switchブロックの後に、</code><a href="https://developer.android.com/reference/android/app/job/JobInfo.Builder.html" target="_blank"><code>JobInfo.Builder</code></a><code>オブジェクトを作成します。最初のパラメータはJOB_IDです。</code>2 <code>番目のパラメータは、作成した JobService の ComponentName です。ComponentName は、JobInfo オブジェクトと JobService を関連付けるために使用されます。</code></li>
</ol>
<pre><code>ComponentName serviceName = new ComponentName(getPackageName(),
       NotificationJobService.class.getName());
JobInfo.Builder builder = new JobInfo.Builder(JOB_ID, serviceName);</code></pre>
<ol type="1" start="1">
<li><code>JobInfo.Builder オブジェクトで setRequiredNetworkType() を呼び出します。選択したネットワークオプションを渡します。</code></li>
</ol>
<pre><code>.setRequiredNetworkType(selectedNetworkOption);</code></pre>
<ol type="1" start="1">
<li><code>JobScheduler オブジェクトで schedule() を呼び出します。build() メソッドを使用して、JobInfo オブジェクトを渡します。</code></li>
</ol>
<pre><code>JobInfo myJobInfo = builder.build();
mScheduler.schedule(myJobInfo);</code></pre>
<ol type="1" start="1">
<li><code>Toast</code>メッセージを表示し、ジョブがスケジュールされていることをユーザーに知らせます。</li>
</ol>
<pre><code>Toast.makeText(this, &#34;Job Scheduled, job will run when &#34; +
       &#34;the constraints are met.&#34;, Toast.LENGTH_SHORT).show();</code></pre>
<ol type="1" start="1">
<li><code>cancelJobs()</code> メソッドで、<code>JobScheduler</code> オブジェクトが <code>null</code> であるかどうかをチェックします。そうでない場合は、そのオブジェクトの <code>cancelAll()</code> を呼び出して、保留中のジョブをすべて削除します。また、<code>JobScheduler</code> を <code>NULL</code> にリセットし、ジョブがキャンセルされたことをユーザに伝えるためのトーストメッセージを表示します。</li>
</ol>
<pre><code>if (mScheduler!=null){
   mScheduler.cancelAll();
   mScheduler = null;
   Toast.makeText(this, &#34;Jobs cancelled&#34;, Toast.LENGTH_SHORT).show();
}</code></pre>
<ol type="1" start="1">
<li>アプリを実行します。これで、ネットワーク制限のあるタスクを設定して、タスクの実行時間を確認することができます。この場合、タスクは通知を配信することです。通知を解除するには、ユーザーは通知をスワイプで遠ざけるか、タップしてアプリを開きます。</li>
</ol>
<p>ネットワークの制約を「<code>Any</code>」や「<code>Wifi</code>」に変更しないと、以下の例外でアプリがクラッシュすることに気づくかもしれません。</p>
<pre><code>java.lang.IllegalArgumentException: 
   You&#39;re trying to build a job with no constraints, this is not allowed.</code></pre>
<p>制約のないジョブを構築しようとすると、これは許されません。</p>
<p>クラッシュが発生するのは、&#34;<code>No Network Required</code>&#34;条件がデフォルトであり、この条件は制約としてカウントされないためです。ジョブサービスを適切にスケジューリングするために、ジョブスケジューラは少なくとも1つの制約を必要とします。</p>
<p>次のセクションでは、少なくとも1つの制約が設定されている場合は真、そうでない場合は偽の条件変数を作成します。条件が真の場合、アプリはタスクをスケジュールします。条件が<code>False</code>の場合、アプリは、ユーザーに制約を設定するように指示するトースト メッセージを表示します。</p>
<p>2.2 制約条件のチェック</p>
<p><code>JobScheduler</code>は少なくとも一つの制約を設定する必要があります。このタスクでは、この要件が満たされているかどうかを追跡するブーリアンを作成します。次のステップで追加のオプションを作成する際には、少なくとも1つの制約が設定されている場合は常に<code>true</code>で、そうでない場合は<code>false</code>になるように、このブール値を修正する必要があります。</p>
<p><code>scheduleJob()内のMainActivity.javaに以下の手順を実装します。</code></p>
<ol type="1" start="1">
<li><code>JobInfo.Builder</code>定義の後、<code>myJobInfo</code>定義の上に、<code>constraintSet</code>という名前のブール変数を作成します。この変数は、選択されたネットワークオプションがデフォルトではない場合に真となります。(デフォルトは <code>JobInfo.NETWORK_TYPE_NONE</code> です。)</li>
</ol>
<pre><code>boolean constraintSet = selectedNetworkOption != JobInfo.NETWORK_TYPE_NONE;</code></pre>
<p><code>boolean constraintSet = selectedNetworkOption != JobInfo.NETWORK_TYPE_NONE.</code></p>
<ol type="1" start="1">
<li><code>constraintSet定義後、constraintSet変数を使用してif/elseブロックを作成します。</code></li>
<li>ジョブをスケジュールし、トーストメッセージを表示するコードを<code>if</code>ブロックに移動します。</li>
<li><code>constraintSet</code>が<code>false</code>の場合は、少なくとも1つの制約を設定するようにユーザーに伝えるトーストメッセージを表示します。文字列リソースの抽出を忘れないでください。</li>
</ol>
<pre><code>if(constraintSet) {
   //Schedule the job and notify the user
   JobInfo myJobInfo = builder.build();
   mScheduler.schedule(myJobInfo);
   Toast.makeText(this, &#34;Job Scheduled, job will run when &#34; +
           &#34;the constraints are met.&#34;, Toast.LENGTH_SHORT).show();
}else {
   Toast.makeText(this, &#34;Please set at least one constraint&#34;,
           Toast.LENGTH_SHORT).show();
}</code></pre>
<p>2.3 デバイスアイドルおよびデバイス充電制約の実装</p>
<p><code>JobScheduler</code>を使用すると、デバイスが充電中になるまで、またはデバイスがアイドル状態（スクリーンオフやCPUがスリープ状態）になるまで、アプリに<code>JobService</code>の実行を待機させることができます。</p>
<p>このセクションでは、アプリにスイッチを追加して、ジョブサービスの制約を切り替えます。</p>
<p>新しい制約のUI要素を追加します。</p>
<p class="image-container"><img alt="623e16d0c5cd11fb.png" style="width: 322.82px" src="img/623e16d0c5cd11fb.png"></p>
<p><code>activity_main.xmlファイルに以下の手順を実装します。</code></p>
<ol type="1" start="1">
<li>ネットワークタイプのラベルに使用した<code>TextView</code>をコピーして、<code>RadioGroup</code>の下に貼り付けます。</li>
<li><code>android:text属性を</code>&#34;<code>Required</code>:&#34;<code>に変更します。</code></li>
<li>その下に、<code>4dp</code>のマージンで水平の<code>LinearLayout</code>を追加します。</li>
</ol>
<table>
<tr><td colspan="1" rowspan="1"><p>属性</p>
</td><td colspan="1" rowspan="1"><p>値</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>レイアウトの幅</p>
</td><td colspan="1" rowspan="1"><p><code>"match_parent"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>レイアウトの高さ</p>
</td><td colspan="1" rowspan="1"><p><code>"</code>ラップコンテンツ<code>"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>オリエンテーション</p>
</td><td colspan="1" rowspan="1"><p><code>"</code>すいへいよう</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>レイアウトマージン</p>
</td><td colspan="1" rowspan="1"><p><code>"4dp"</code></p>
</td></tr>
</table>
<ol type="1" start="1">
<li>水平方向の<code>LinearLayout</code>の子として2つの<code>Switch</code>ビューを作成します。高さと幅を&#34;<code>wrap_content"</code>に設定し、以下の属性を使用します。</li>
</ol>
<table>
<tr><td colspan="2" rowspan="1"><p>スイッチ1</p>
</td><td colspan="1" rowspan="1"></td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>テキスト</p>
</td><td colspan="1" rowspan="1"><p><code>"</code>デバイスアイドル</p>
</td><td colspan="1" rowspan="1"></td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:id</code></p>
</td><td colspan="1" rowspan="1"><p><code>"@+id/idleSwitch"</code></p>
</td><td colspan="1" rowspan="1"></td></tr>
<tr><td colspan="2" rowspan="1"><p>スイッチ2</p>
</td><td colspan="1" rowspan="1"></td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>テキスト</p>
</td><td colspan="1" rowspan="1"><p><code>"</code>デバイス充電<code>"</code></p>
</td><td colspan="1" rowspan="1"></td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:id</code></p>
</td><td colspan="1" rowspan="1"><p><code>"@+id/chargingSwitch"</code></p>
</td><td colspan="1" rowspan="1"></td></tr>
</table>
<p>新しい制約のコードを追加します。</p>
<p><code>MainActivity.javaに以下の手順を実装します。</code></p>
<ol type="1" start="1">
<li><code>スイッチ用の mDeviceIdle と mDeviceCharging というメンバ変数を作成します。onCreate()で変数を初期化します。</code></li>
</ol>
<pre><code>//Switches for setting job options
private Switch mDeviceIdleSwitch;
private Switch mDeviceChargingSwitch;</code></pre>
<p><code>onCreate()を使用しています。</code></p>
<pre><code>mDeviceIdleSwitch = findViewById(R.id.idleSwitch);
mDeviceChargingSwitch = findViewById(R.id.chargingSwitch);</code></pre>
<ol type="1" start="1">
<li><code>scheduleJob()</code> メソッドで、以下の呼び出しを追加します。これらの呼び出しは、ビルダーオブジェクトの作成中に、<code>Switch</code>ビューでのユーザの選択に基づいて、<code>JobInfo.Builder</code>に制約を設定します。</li>
</ol>
<pre><code>.setRequiresDeviceIdle(mDeviceIdleSwitch.isChecked())
.setRequiresCharging(mDeviceChargingSwitch.isChecked());</code></pre>
<ol type="1" start="1">
<li>新しい制約を考慮して <code>constraintSet</code> を設定するコードを更新します。</li>
</ol>
<pre><code>boolean constraintSet = (selectedNetworkOption != JobInfo.NETWORK_TYPE_NONE)
       || mDeviceChargingSwitch.isChecked() || mDeviceIdleSwitch.isChecked();

</code></pre>
<ol type="1" start="1">
<li>追加の制約を加えてアプリを実行します。ジョブが実行されたことを示す通知が送信されるタイミングを確認するために、スイッチのさまざまな組み合わせを試してみてください。</li>
</ol>
<p>エミュレータで充電状態の制約をテストするには</p>
<ol type="1" start="1">
<li>Moreメニュー（エミュレートされたデバイスの横にある楕円形のアイコン）を開きます。</li>
<li>バッテリーペインに移動します。</li>
<li>Battery Status ドロップダウンメニューをトグルします。現在のところ、エミュレータを手動でアイドルモードにする方法はありません。</li>
</ol>
<p>大容量ファイルのダウンロードやアップロードなど、バッテリーを必要とする作業の場合、デバイスがアイドル状態になって電源に接続されるまで待つのが一般的なパターンです。</p>
<p>2.4 オーバーライド期限制約の実装</p>
<p>ここまでは、フレームワークがいつタスクを実行するかを正確に知る方法はありません。システムは効率的なリソース管理を考慮しているため、デバイスの状態によってはタスクが遅れる可能性があり、タスクが時間通りに実行されることを保証するものではありません。</p>
<p><code>JobScheduler</code> APIには、以前のすべての制約を上書きするハードデッドラインを設定する機能が含まれています。</p>
<p>タスクの実行期限を設定するための新しいUIを追加する</p>
<p class="image-container"><img alt="48a34f6cbb7ecd6f.png" style="width: 273.47px" src="img/48a34f6cbb7ecd6f.png"></p>
<p>このステップでは、<a href="https://developer.android.com/reference/android/widget/SeekBar.html" target="_blank">シークバー</a>を使用して、ユーザーがタスクの実行期限を0～100秒の間で設定できるようにします。ユーザーはシークバーを左右にドラッグして値を設定します。</p>
<p><code>activity_main.xmlファイルに以下の手順を実装します。</code></p>
<ol type="1" start="1">
<li><code>スイッチ・ビューのあるLinearLayoutの下に、水平のLinearLayoutを作成します。新しいLinearLayoutはSeekBarラベル用です。</code></li>
</ol>
<table>
<tr><td colspan="1" rowspan="1"><p>属性</p>
</td><td colspan="1" rowspan="1"><p>値</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>レイアウトの幅</p>
</td><td colspan="1" rowspan="1"><p><code>"match_parent"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>レイアウトの高さ</p>
</td><td colspan="1" rowspan="1"><p><code>"</code>ラップコンテンツ<code>"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>オリエンテーション</p>
</td><td colspan="1" rowspan="1"><p><code>"</code>すいへいよう</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>レイアウトマージン</p>
</td><td colspan="1" rowspan="1"><p><code>"4dp"</code></p>
</td></tr>
</table>
<ol type="1" start="1">
<li>シークバーには、ラジオボタンのグループのラベルのような静的ラベルと、シークバーの値で更新される動的ラベルの 2 つのラベルを与えます。次の属性を持つ 2 つの <code>TextView</code> ビューを <code>LinearLayout</code> に追加します。</li>
</ol>
<table>
<tr><td colspan="2" rowspan="1"><p>テキストビュー 1</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>レイアウトの幅</p>
</td><td colspan="1" rowspan="1"><p><code>"</code>ラップコンテンツ<code>"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>レイアウトの高さ</p>
</td><td colspan="1" rowspan="1"><p><code>"</code>ラップコンテンツ<code>"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>テキスト</p>
</td><td colspan="1" rowspan="1"><p><code>"</code>期限をオーバーライド<code>"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:id</code></p>
</td><td colspan="1" rowspan="1"><p><code>"@+id/seekBarLabel"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>android:textAppearance</code></p>
</td><td colspan="1" rowspan="1"><p><code>"@style/TextAppearance.AppCompat.Subhead"</code></p>
</td></tr>
<tr><td colspan="2" rowspan="1"><p>テキストビュー 2</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>レイアウトの幅</p>
</td><td colspan="1" rowspan="1"><p><code>"</code>ラップコンテンツ<code>"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>レイアウトの高さ</p>
</td><td colspan="1" rowspan="1"><p><code>"</code>ラップコンテンツ<code>"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>テキスト</p>
</td><td colspan="1" rowspan="1"><p><code>"</code>未設定<code>"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:id</code></p>
</td><td colspan="1" rowspan="1"><p><code>"@+id/seekBarProgress"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>android:textAppearance</code></p>
</td><td colspan="1" rowspan="1"><p><code>"@style/TextAppearance.AppCompat.Subhead"</code></p>
</td></tr>
</table>
<ol type="1" start="1">
<li><code>LinearLayout</code> の下に <code>SeekBar</code> ビューを追加します。次の属性を使用します。</li>
</ol>
<table>
<tr><td colspan="1" rowspan="1"><p>属性</p>
</td><td colspan="1" rowspan="1"><p>値</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>レイアウトの幅</p>
</td><td colspan="1" rowspan="1"><p><code>"match_parent"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>レイアウトの高さ</p>
</td><td colspan="1" rowspan="1"><p><code>"</code>ラップコンテンツ<code>"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:id</code></p>
</td><td colspan="1" rowspan="1"><p><code>"@+id/seekBar"</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>アンドロイド<code>:</code>レイアウトマージン</p>
</td><td colspan="1" rowspan="1"><p><code>"4dp"</code></p>
</td></tr>
</table>
<p>締め切りを追加するコードを書く</p>
<p>以下の手順を<code>MainActivity.java</code>に実装します。文字列リソースを抽出することを忘れないでください。</p>
<ol type="1" start="1">
<li><code>SeekBar</code>のメンバ変数を作成し、<code>onCreate()</code>で初期化します。</li>
</ol>
<pre><code>//Override deadline seekbar
private SeekBar mSeekBar;</code></pre>
<p><code>//</code>シークバーの期限をオーバーライド</p>
<p><code>private SeekBar mSeekBar.</code></p>
<p><code>onCreate()を使用しています。</code></p>
<pre><code>mSeekBar = findViewById(R.id.seekBar);</code></pre>
<ol type="1" start="1">
<li><code>onCreate()</code>で、シーク・バーのプログレス・テキストビュー用の最終変数を作成して初期化します。(この変数は内部クラスからアクセスされます)。</li>
</ol>
<pre><code>final TextView seekBarProgress = findViewById(R.id.seekBarProgress);</code></pre>
<ol type="1" start="1">
<li><code>onCreate()で、新しいOnSeekBarChangeListenerを渡してシークバー上でsetOnSeekBarChangeListener()を呼び出します。</code>(Android Studio<code>が必要なメソッドを生成してくれるはずです</code>)<code>。</code></li>
</ol>
<pre><code>mSeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
   @Override
   public void onProgressChanged(SeekBar seekBar, int i, boolean b) {}

   @Override
   public void onStartTrackingTouch(SeekBar seekBar) {}

   @Override
   public void onStopTrackingTouch(SeekBar seekBar) {}
});</code></pre>
<ol type="1" start="1">
<li><code>onProgressChanged()</code>の第2引数は、シークバーの現在の値です。<code>onProgressChanged()</code> コールバックでは、整数値が <code>0</code> より大きいかどうかをチェックします（ユーザーが値を設定したことを意味します）。値が<code>0</code>より大きい場合は、シークバーの進捗ラベルを整数値に設定し、秒を示す秒の後に<code>s</code>を付けます。そうでなければ、テキストビューを<code>"Not Set"</code>と読むように設定します。</li>
</ol>
<pre><code>if (i &gt; 0){
   seekBarProgress.setText(i + &#34; s&#34;);
}else {
   seekBarProgress.setText(&#34;Not Set&#34;);
}</code></pre>
<ol type="1" start="1">
<li>オーバーライド期限は、シークバーの整数値が <code>0</code> より大きい場合にのみ設定する必要があります。 <code>scheduleJob()</code> メソッドで、シークバーの進行状況を格納するための <code>int</code> を作成します。また、シークバーの整数値が <code>0</code> より大きい場合に真となるブール変数も作成します。</li>
</ol>
<pre><code>int seekBarInteger = mSeekBar.getProgress();
boolean seekBarSet = seekBarInteger &gt; 0;</code></pre>
<ol type="1" start="1">
<li>ビルダー定義後の <code>scheduleJob()</code> メソッドで、<code>seekBarSet</code> が <code>true</code> の場合、<code>JobInfo.Builder</code> で <code>setOverrideDeadline()</code> を呼び出します。シークバーの整数値に1000を掛けた値を渡します。(パラメータはミリ秒単位で、ユーザーが秒単位で期限を設定したい場合)。</li>
</ol>
<pre><code>if (seekBarSet) {
      builder.setOverrideDeadline(seekBarInteger * 1000);
}</code></pre>
<ol type="1" start="1">
<li><code>可能な制約として seekBarSet の値を含めるように constraintSet を変更します。</code></li>
</ol>
<pre><code>boolean constraintSet = selectedNetworkOption != JobInfo.NETWORK_TYPE_NONE
       || mDeviceChargingSwitch.isChecked() || mDeviceIdleSwitch.isChecked()
       || seekBarSet;</code></pre>
<ol type="1" start="1">
<li>アプリを実行します。ユーザーは、ジョブサービスが実行されなければならないハードデッドラインを秒単位で設定できるようになりました!</li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="Solution code" duration="0">
        <p>Android Studioプロジェクト。<a href="https://github.com/google-developer-training/android-fundamentals-apps-v2/tree/master/NotificationScheduler" target="_blank">NotificationScheduler</a></p>


      </google-codelab-step>
    
      <google-codelab-step label="Coding challenge" duration="0">
        <p>注: コーディングの課題はすべて任意であり、後のレッスンの前提条件ではありません。</p>
<p>課題: これまで、ジョブサービスのタスクは単に通知を配信していましたが、ジョブスケジューラは通常、天気の更新やデータベースとの同期など、より堅牢なバックグラウンドタスクに使用されていました。バックグラウンドタスクは、プログラム的にも機能的にもより複雑になる可能性があるため、タスクが完了したときにフレームワークに通知する仕事は開発者に任されています。幸いなことに、開発者は <code>jobFinished()</code> を呼び出すことでこれを行うことができます。</p>
<p>この課題では、タスクが完了した後に <code>jobFinished()</code> を呼び出す必要があります。</p>
<ul>
<li>与えられた制約が満たされたときに<code>AsyncTask</code>を起動する<code>JobService</code>を実装します。</li>
<li><code>AsyncTask</code> は 5 秒間スリープする必要があります。</li>
<li>スレッドがスリープしている間に制約が満たされなくなった場合、ジョブを再スケジュールし、ジョブが失敗したことを示す<code>Toast</code>メッセージを表示します。</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Summary" duration="0">
        <ul>
<li><code>JobScheduler</code>は、バックグラウンドサービスをインテリジェントに実行するための柔軟なフレームワークを提供します。</li>
<li><code>JobScheduler</code>はAPI 21以上のデバイスでのみ利用可能です。</li>
<li><code>JobSchedulerを使用するには、</code>2<code>つのパーツが必要です。JobService と JobInfo です。</code></li>
<li><code>JobInfo</code>は、ジョブを実行するトリガーとなる条件のセットです。</li>
<li><code>JobService</code>は、<code>JobInfo</code>で指定された条件で実行するジョブを実装します。</li>
<li><code>onStartJob() と onStopJob() コールバックメソッドを実装する必要があります。</code></li>
<li>ジョブの実装は、<code>onStartJob()</code>で発生するか、開始されます。</li>
<li><code>onStartJob()</code>メソッドは、サービスが別のスレッドで作業を処理する必要があるかどうかを示すブール値を返します。</li>
<li>onStartJob()が<code>true</code>を返す場合、明示的に<code>jobFinished()</code>を呼び出す必要があります。onStartJob() が <code>false</code> を返す場合、ランタイムはあなたに代わって <code>jobFinished()</code> を呼び出します。</li>
<li><code>JobService</code>はメインスレッドで処理されるので、長時間の計算やI/Oは避けるべきです。</li>
<li><code>JobScheduler</code> は、タスクのスケジューリングを担当するマネージャクラスです。<code>JobScheduler</code> は、システムリソースの効率を最大化するためにタスクをバッチ処理しますが、これはタスクがいつ実行されるかを正確に制御できないことを意味します。</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Related concept" duration="0">
        <p>関連する概念のドキュメントは「<a href="https://google-developer-training.github.io/android-developer-fundamentals-course-concepts-v2/unit-3-working-in-the-background/lesson-8-alarms-and-schedulers/8-3-c-efficient-data-transfer/8-3-c-efficient-data-transfer.html" target="_blank">8.3: 効率的なデータ転送」</a>にあります。</p>


      </google-codelab-step>
    
      <google-codelab-step label="Learn more" duration="0">
        <p>Androidの開発者向けドキュメント。</p>
<ul>
<li><a href="https://developer.android.com/reference/android/app/job/JobScheduler.html" target="_blank">ジョブスケジューラ</a></li>
<li><a href="https://developer.android.com/reference/android/app/job/JobInfo.html" target="_blank">ジョブ情報</a></li>
<li><a href="https://developer.android.com/reference/android/app/job/JobInfo.Builder.html" target="_blank"><code>JobInfo.Builder</code></a></li>
<li><a href="https://developer.android.com/reference/android/app/job/JobService.html" target="_blank">ジョブサービス</a></li>
<li><a href="https://developer.android.com/reference/android/app/job/JobParameters.html" target="_blank">ジョブパラメタ</a></li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Homework" duration="0">
        <p>このセクションでは、インストラクターが主導するコースの一部として、このコードラボを通して作業する学生のための可能な宿題をリストアップします。以下のことをするかどうかはインストラクター次第です。</p>
<ul>
<li>必要に応じて宿題を出す。</li>
<li>宿題の提出方法を学生に伝える。</li>
<li>宿題を採点します。</li>
</ul>
<p>講師は、彼らが望むように少しまたは多くのようにこれらの提案を使用することができますし、彼らが適切であると感じる他の宿題を割り当てるために自由に感じるはずです。</p>
<p>もしあなた自身でこのコードラボに取り組んでいるのであれば、これらの宿題を使ってあなたの知識をテストしてみてはいかがでしょうか。</p>
<p>アプリを構築して実行する</p>
<p>バッテリーとデータの消費を考慮してスケジュールされた大規模なダウンロードをシミュレートするアプリを作成します。アプリには「Download Now」ボタンが含まれており、以下のような機能があります。</p>
<ul>
<li>実際のダウンロードを行う代わりに、アプリは通知を配信します。</li>
<li>ユーザーが「今すぐダウンロード」ボタンをタップすると、「ダウンロード中」の通知がトリガーされます。</li>
<li>ダウンロード」は1日1回、スマホがアイドル状態でも電源とWi-Fiに接続されているとき、またはボタンをタップしたときに行われます。</li>
</ul>
<p>ヒント :<code>JobService</code> クラスを内部クラスとして定義します。そうすることで、Download Nowボタンと<code>JobService</code>が同じメソッドを呼び出して通知を配信することができます。</p>
<p class="image-container"><img alt="JobScheduler delivers a notification based on phone status" style="width: 267.94px" src="img/40accdd2a0095688.png"></p>
<p>注意：デバイスのAPIレベルによっては、通知が少し違って見える場合があります。</p>
<p>以下の質問に答えてください。</p>
<p>質問1</p>
<p><code>JobScheduler</code>で提供されているような機能が欲しいが、APIレベル20以下のデバイスでも動作するようにしたい場合は、どのクラスを使用しますか？</p>
<ul>
<li>ジョブスケジューラーコンパット</li>
<li>ワークマネージャ</li>
<li>アラームマネージャ</li>
</ul>
<p>アプリを提出して採点を受ける</p>
<p>学年別ガイダンス</p>
<p>アプリが以下の機能を持っているかどうかを確認しましょう。</p>
<ul>
<li><code>JobInfoオブジェクトには、setRequiresCharging</code>()<code>、setPeriodic</code>()<code>、setRequiresDeviceIdle</code>()<code>、setRequiredNetworkType()の</code>4<code>つの基準が設定されています。</code></li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Next codelab" duration="0">
        <p>Android Developer Fundamentals (V2)コースの次の実践的なコードラボを見つけるには、<a href="https://developer.android.com/courses/fundamentals-training/toc-v2" target="_blank">Codelabs for Android Developer Fundamentals (V2)を</a>参照してください。</p>
<p>概念章、アプリ、スライドへのリンクを含むコースの概要については、<a href="https://developer.android.com/courses/fundamentals-training/overview-v2" target="_blank">Android Developer Fundamentals (Version 2)を</a>参照してください。</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
